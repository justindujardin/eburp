/// <reference path="../types/backbone/backbone.d.ts" />
/// <reference path="../types/angularjs/angular.d.ts" />
/// <reference path="../web/bower/pow-core/lib/pow-core.d.ts" />
/// <reference path="pow2.d.ts" />
/// <reference path="pow2.ui.d.ts" />
/**
 * Dorkapon is constructed with a set of components and state machines.
 *
 * The front-end is built using Angular.JS directives and controllers that
 * use an asynchronous state machine event handler to integrate the UI elements
 * into the underlying states.
 */
declare module dorkapon {
    /**
     * The name of this app.  You can fetch the game world at any time using pow2.getWorld and this name.
     * @type {string}
     */
    var NAME: string;
    /**
     * The Google Spreadsheet ID to load game data from.  This must be a published
     * google spreadsheet key.
     * @type {string} The google spreadsheet ID
     */
    var SPREADSHEET_ID: string;
    /**
     * The location of the entities container for dorkapon.
     *
     * This file contains template descriptions for the various complex game objects.
     */
    var ENTITIES_CONTAINER: string;
    var app: ng.IModule;
    /**
     * Item with representative icon from google spreadsheet.
     */
    interface IDorkaponItem {
        /**
         * The sprite icon name, e.g. "shortSword.png"
         */
        icon: string;
        /**
         * The hyphen-case unique item id.
         */
        id: string;
        /**
         * The human readable formatted name of the item.
         */
        name: string;
    }
    /**
     * An equipment item from the spreadsheet that buffs
     * character stats.
     */
    interface IDorkaponEquipment extends IDorkaponItem {
        attack: number;
        defense: number;
        speed: number;
        magic: number;
        hp: number;
    }
}
declare module dorkapon.components {
    interface IMapNodeComponent {
        world: DorkaponGameWorld;
        /**
         * Perform any action associated with landing on this component.
         * @param object The entity that landed on the node.
         * @param then A callback to be invoked when the action is done.
         */
        doAction(object: objects.DorkaponEntity, then: () => any): any;
    }
    class MapNodeComponent extends pow2.tile.TileComponent implements IMapNodeComponent {
        world: DorkaponGameWorld;
        /**
         * Perform any action associated with landing on this component.
         * @param object The entity that landed on the node.
         * @param then A callback to be invoked when the action is done.
         */
        doAction(object: objects.DorkaponEntity, then: () => any): void;
        entered(object: objects.DorkaponEntity): boolean;
    }
}
declare module dorkapon.components {
    class ChoiceRollComponent extends pow2.scene.SceneViewComponent {
        target: objects.DorkaponEntity;
        choices: any[];
        host: DorkaponMapView;
        started: boolean;
        items: dorkapon.IDorkaponItem[];
        startAngle: number;
        arc: number;
        spinTimeout: number;
        spinAngleStart: number;
        spinTime: number;
        spinTimeTotal: number;
        selection: dorkapon.IDorkaponItem;
        ctx: CanvasRenderingContext2D;
        constructor(target: objects.DorkaponEntity, choices: any[]);
        connectComponent(): boolean;
        disconnectComponent(): boolean;
        afterFrame(view: DorkaponMapView, elapsed: number): void;
        drawRouletteWheel(view: DorkaponMapView): void;
        spin(view: DorkaponMapView): void;
        rotateWheel(view: DorkaponMapView): void;
        stopRotateWheel(view: DorkaponMapView): void;
        easeOut(t: any, b: any, c: any, d: any): any;
        private _renderPoint;
        private _iconCache;
        renderIcon(icon: string, at: pow2.Point, view: DorkaponMapView): void;
    }
}
declare module dorkapon.components {
    /**
     * A centered camera on the host object, that is clamped
     * inside the tile map.  The result is that the player will
     * be camera center at all times except when he is near an
     * edge of the map.
     */
    class PlayerCamera extends pow2.scene.components.CameraComponent {
        host: objects.DorkaponEntity;
        private _worker;
        private _workerRect;
        process(view: pow2.tile.TileMapView): void;
    }
}
declare module dorkapon.components {
    /**
     * Basic Dorkapon player that can navigate around the map
     * using the paths defined within.
     */
    class PlayerComponent extends pow2.scene.components.PlayerComponent {
        host: objects.DorkaponEntity;
        heading: pow2.Point;
        paths: PlayerPathComponent;
        map: pow2.tile.TileMap;
        syncComponent(): boolean;
        /**
         * Collide with the A-star graph input data generated by a path component.
         */
        collideMove(x: number, y: number, results?: pow2.scene.SceneObject[]): boolean;
    }
}
declare module dorkapon.components {
    /**
     * Generate an A* path given a dorkapon tile map.
     */
    class PlayerPathComponent extends pow2.tile.components.PathComponent {
        tileMap: DorkaponTileMap;
        buildWeightedGraph(): number[][];
    }
}
declare module dorkapon.components {
    /**
     * Knows about the dorkapon game world and state machine.  Exposes methods
     * for interacting with the state machine on a per-player basis.
     *
     * isCurrentTurn() - check host is state machine current player
     *
     */
    class PlayerTurnComponent extends pow2.scene.SceneComponent {
        machine: DorkaponMapStateMachine;
        host: objects.DorkaponEntity;
        /**
         * The callback to signal the state machine to move on to the
         * next player's turn.
         */
        turnDone: () => any;
        /**
         * Constructs with a given state machine.
         */
        constructor(machine: DorkaponMapStateMachine);
        connectComponent(): boolean;
        disconnectComponent(): boolean;
        /**
         * Determine if the given entity is the currently active player.
         */
        isCurrentTurn(entity?: objects.DorkaponEntity): boolean;
        /**
         * Subtract one move from the current player.
         */
        decrementMove(): void;
        private _machineCapture(data);
    }
}
declare module dorkapon {
    class DorkaponCombatStateMachine extends pow2.StateMachine {
        scene: pow2.scene.Scene;
        parent: DorkaponAppStateMachine;
        static Events: any;
        /**
         * The [DorkaponGameWorld]
         */
        world: DorkaponGameWorld;
        /**
         * The [DorkaponEntity] on the left side of the fight.
         */
        left: objects.DorkaponEntity;
        /**
         * The [DorkaponEntity] on the right side of the fight.
         */
        right: objects.DorkaponEntity;
        /**
         * The currently attacking [DorkaponEntity] object.
         */
        attacker: objects.DorkaponEntity;
        /**
         * The currently defending [DorkaponEntity] in combat.
         */
        defender: objects.DorkaponEntity;
        /**
         * The attacker's chosen action.
         */
        attackerMove: states.MoveChoice;
        /**
         * The defender's chosen action.
         */
        defenderMove: states.MoveChoice;
        states: pow2.IState[];
        constructor(attacker: models.DorkaponEntity, defender: models.DorkaponEntity, scene: pow2.scene.Scene, parent: DorkaponAppStateMachine);
        createPlayer(from: models.DorkaponEntity, at?: pow2.Point): objects.DorkaponEntity;
    }
}
declare module dorkapon.states {
    enum MoveChoice {
        ATTACK = 1,
        ATTACK_MAGIC = 2,
        ATTACK_SKILL = 3,
        STRIKE = 4,
        DEFEND = 5,
        DEFEND_MAGIC = 6,
        DEFEND_SKILL = 7,
        COUNTER = 8,
    }
    interface ICombatAttackSummary {
        attacker: objects.DorkaponEntity;
        defender: objects.DorkaponEntity;
        attackerMove: MoveChoice;
        defenderMove: MoveChoice;
        attackerDamage: number;
        defenderDamage: number;
    }
    interface ICombatChooseMove {
        attacker: objects.DorkaponEntity;
        defender: objects.DorkaponEntity;
        report(player: objects.DorkaponEntity, move: MoveChoice): any;
    }
    /**
     * Notification to determine turn order.
     */
    interface ICombatDetermineTurnOrder {
        attacker: objects.DorkaponEntity;
        defender: objects.DorkaponEntity;
        report(first: objects.DorkaponEntity, second: objects.DorkaponEntity): any;
    }
    class AppCombatStateBase extends pow2.State {
        machine: DorkaponCombatStateMachine;
        constructor(machine: DorkaponCombatStateMachine);
    }
    /**
     * Initialize combat between two entities, roll turns and determine
     * who attacks first.
     *
     * Transitions to [DorkaponCombatChooseMoves].
     */
    class DorkaponCombatInit extends AppCombatStateBase {
        static NAME: string;
        static EVENT: string;
        name: string;
        enter(machine: DorkaponCombatStateMachine): void;
    }
    interface ICombatSummary {
        winner: objects.DorkaponEntity;
        loser: objects.DorkaponEntity;
    }
    class DorkaponCombatEnded extends AppCombatStateBase {
        static NAME: string;
        static EVENT: string;
        name: string;
        enter(machine: DorkaponCombatStateMachine): void;
    }
    class DorkaponCombatChooseMoves extends AppCombatStateBase {
        static NAME: string;
        static EVENT: string;
        name: string;
        enter(machine: DorkaponCombatStateMachine): void;
        exit(machine: DorkaponCombatStateMachine): void;
    }
    class DorkaponCombatExecuteMoves extends AppCombatStateBase {
        static NAME: string;
        static EVENT: string;
        name: string;
        tileMap: DorkaponTileMap;
        enter(machine: DorkaponCombatStateMachine): void;
    }
}
declare module dorkapon.components.tiles {
    class ArmorTile extends MapNodeComponent {
        /**
         * Display the armor tile chance roll.
         */
        doAction(object: objects.DorkaponEntity, then: () => any): void;
    }
}
declare module dorkapon.components.tiles {
    class BlueTile extends MapNodeComponent {
        enter(object: objects.DorkaponEntity): boolean;
    }
}
declare module dorkapon.components.tiles {
    class GreenTile extends MapNodeComponent {
        enter(object: objects.DorkaponEntity): boolean;
    }
}
declare module dorkapon.components.tiles {
    class ItemTile extends MapNodeComponent {
        /**
         * Display the weapon tile chance roll.
         */
        doAction(object: objects.DorkaponEntity, then: () => any): void;
    }
}
declare module dorkapon.components.tiles {
    class RedTile extends MapNodeComponent {
        enter(object: objects.DorkaponEntity): boolean;
    }
}
declare module dorkapon.components.tiles {
    class WeaponTile extends MapNodeComponent {
        /**
         * Display the weapon tile chance roll.
         */
        doAction(object: objects.DorkaponEntity, then: () => any): void;
    }
}
declare module dorkapon.components.tiles {
    class YellowTile extends MapNodeComponent {
        machine: dorkapon.DorkaponCombatStateMachine;
        /**
         * Roll and present a random encounter with a bad guy.
         */
        doAction(object: objects.DorkaponEntity, then: () => any): void;
        enter(object: objects.DorkaponEntity): boolean;
    }
}
declare module dorkapon.controllers {
    class CharacterCardController {
        model: models.DorkaponEntity;
    }
}
declare module dorkapon.controllers {
    class CombatHudController {
        $scope: any;
        $rootScope: any;
        $timeout: ng.ITimeoutService;
        $mdDialog: any;
        $dorkapon: services.DorkaponService;
        $damageValue: pow2.ui.services.DamageValueService;
        static $inject: string[];
        constructor($scope: any, $rootScope: any, $timeout: ng.ITimeoutService, $mdDialog: any, $dorkapon: services.DorkaponService, $damageValue: pow2.ui.services.DamageValueService);
        combat: dorkapon.DorkaponCombatStateMachine;
        getHitPointValue(object: objects.DorkaponEntity): number;
        /**
         * Listen to various combat events to coordinate combat action selection
         * and dynamic state embellishments.
         *
         * @param state The combat state to listen in on.
         */
        listenCombatEvents(state: states.AppCombatState): void;
        stopListeningCombatEvents(state: states.AppCombatState): void;
        pickTurnOrderCard(turnOrder: states.ICombatDetermineTurnOrder, then: () => any): void;
        /**
         * Pick what type of move to execute for a player.
         * @param chooseMove The [[ICombatChooseMove]] event with details about players.
         * @param attacker True if picking for the attacker, false if for the defender.
         * @param then The callback to invoke once a move has been chosen and reported.
         */
        pickMove(chooseMove: states.ICombatChooseMove, attacker: boolean, then: () => any): void;
    }
}
declare module dorkapon {
    class DorkaponMapStateMachine extends pow2.StateMachine {
        world: DorkaponGameWorld;
        playerPool: objects.DorkaponEntity[];
        playerQueue: objects.DorkaponEntity[];
        /**
         * The active player [DorkaponEntity] object.
         */
        currentPlayer: objects.DorkaponEntity;
        /**
         * The active player last contacted node.
         */
        currentNode: components.MapNodeComponent;
        states: pow2.IState[];
    }
}
declare module dorkapon.states {
    class DorkaponInitGame extends pow2.State {
        static NAME: string;
        name: string;
        enter(machine: DorkaponMapStateMachine): void;
    }
    class DorkaponBeginTurns extends pow2.State {
        static NAME: string;
        name: string;
        enter(machine: DorkaponMapStateMachine): void;
    }
    interface IPlayerTurnEvent {
        player: objects.DorkaponEntity;
    }
    class DorkaponPlayerTurn extends pow2.State {
        static NAME: string;
        static EVENT: string;
        name: string;
        tileMap: DorkaponTileMap;
        enter(machine: DorkaponMapStateMachine): void;
    }
    class DorkaponPlayerTurnEnd extends pow2.State {
        static NAME: string;
        static EVENT: string;
        name: string;
        enter(machine: DorkaponMapStateMachine): void;
    }
}
declare module dorkapon {
    class DorkaponGameWorld extends pow2.scene.SceneWorld {
        /**
         * The main application state, e.g. Map, Combat, Menu.
         */
        state: DorkaponAppStateMachine;
        /**
         * The current combat state (if any).  The presence of this
         * state machine being valid may trigger the game UI to transition
         * to combat.
         *
         * This variable should be set to null when no combat is taking place.
         */
        combatState: DorkaponCombatStateMachine;
        /**
         * Dorkapon specific Google Spreadsheet data.
         */
        tables: pow2.GameDataResource;
        /**
         * Factory for creating entity objects from templates.
         */
        factory: pow2.EntityContainerResource;
        /**
         * The view used for rendering the game map.
         */
        mapView: DorkaponMapView;
        constructor(services?: any);
        /**
         * Get the game data sheets from google and callback when they're loaded.
         * @param then The function to call when spreadsheet data has been fetched
         */
        static getDataSource(then?: (data: pow2.GameDataResource) => any): pow2.GameDataResource;
    }
}
declare module dorkapon.services {
    class DorkaponService {
        compile: ng.ICompileService;
        scope: ng.IRootScopeService;
        loader: pow2.ResourceLoader;
        world: DorkaponGameWorld;
        machine: DorkaponAppStateMachine;
        constructor(compile: ng.ICompileService, scope: ng.IRootScopeService);
        /**
         * Start a new game.
         * @param then
         */
        newGame(then?: () => any): void;
        /**
         * Extract the browser location query params
         * http://stackoverflow.com/questions/9241789/how-to-get-url-params-with-javascript
         */
        qs(): any;
    }
}
declare module dorkapon.controllers {
}
declare module dorkapon.controllers {
    class MapHudController {
        $scope: any;
        $dorkapon: services.DorkaponService;
        $mdDialog: any;
        static $inject: string[];
        constructor($scope: any, $dorkapon: services.DorkaponService, $mdDialog: any);
        /**
         * The current player turn.
         */
        turn: dorkapon.states.IPlayerTurnEvent;
        showPlayerCard(player: objects.DorkaponEntity): void;
    }
}
declare module dorkapon.controllers {
    class CombatChooseMoveController {
        $scope: any;
        $timeout: ng.ITimeoutService;
        $mdDialog: any;
        static $inject: string[];
        constructor($scope: any, $timeout: ng.ITimeoutService, $mdDialog: any);
        event: states.ICombatChooseMove;
        attack: boolean;
        current: objects.DorkaponEntity;
        physicalText: string;
        magicText: string;
        specialText: string;
        skillText: string;
        /**
         * Select the desired move type.
         * @param type
         */
        select(type: string): void;
    }
}
declare module dorkapon.controllers {
    class CombatTurnOrderController {
        $scope: any;
        $timeout: ng.ITimeoutService;
        $mdDialog: any;
        combat: dorkapon.DorkaponCombatStateMachine;
        leftText: string;
        rightText: string;
        left: boolean;
        right: boolean;
        picking: boolean;
        pickCorrect: boolean;
        pick: any;
        static $inject: string[];
        constructor($scope: any, $timeout: ng.ITimeoutService, $mdDialog: any);
    }
}
declare module dorkapon.directives {
    class DorkaponHudController implements pow2.IProcessObject {
        $dorkapon: services.DorkaponService;
        scope: any;
        $timeout: any;
        static $inject: string[];
        constructor($dorkapon: services.DorkaponService, scope: any, $timeout: any);
    }
}
declare module dorkapon {
    class DorkaponMapView extends pow2.game.GameMapView {
        world: dorkapon.DorkaponGameWorld;
        tileMap: DorkaponTileMap;
        targetFill: string;
        targetStroke: string;
        targetStrokeWidth: number;
        stateMachine: DorkaponMapStateMachine;
        processCamera(): void;
        mouseClick(e: any): boolean;
        renderFrame(elapsed: number): DorkaponMapView;
    }
}
declare module dorkapon.directives {
}
declare module dorkapon {
    /**
     * These are currently hardcoded to specific tile set GID numbers that
     * correspond to the various connector graphics used to represent horizontal
     * and vertical paths.
     *
     * These specific textures are used to dynamically build paths between nodes.
     */
    enum PathTiles {
        HORIZ_LEFT = 25,
        HORIZ_CENTER = 26,
        HORIZ_RIGHT = 27,
        VERT_TOP = 34,
        VERT_MIDDLE = 35,
        VERT_BOTTOM = 36,
    }
    /**
     * These are hardcoded to specific tile set GID numbers that correspond to
     * the various types of nodes a player may land on.
     *
     * These specific textures are used to indicate metadata about the tile.
     */
    enum NodeTiles {
        YELLOW = 54,
        ARMOR = 58,
        WEAPON = 59,
        ITEM = 60,
        RED = 63,
        BLUE = 72,
        GREEN = 71,
    }
    /**
     * Enumerated path weights for use in input grid creation.
     */
    enum PathWeights {
        CAN_REST = 10,
        CAN_WALK = 5,
        BLOCKED = 1000,
    }
    /**
     * Describe where in the map a node tile exists, and what type it is.
     */
    interface INodeTile extends pow2.IPoint {
        type: NodeTiles;
        _object: objects.DorkaponEntity;
    }
    /**
     * Describe where in the map a path tile exists, and what type it is.
     */
    interface IPathTile extends pow2.IPoint {
        type: PathTiles;
        _object: objects.DorkaponEntity;
    }
    class DorkaponTileMap extends pow2.tile.TileMap {
        static Layers: any;
        world: DorkaponGameWorld;
        loaded(): void;
        destroy(): void;
        unloaded(): void;
        addFeaturesToScene(): void;
        removeFeaturesFromScene(): void;
        buildFeatures(): boolean;
        createFeatureObject(node: INodeTile): objects.DorkaponEntity;
        /**
         * Get a list of INodeTile objects that exist in the tile map.
         */
        getNodes(): INodeTile[];
        getHorizPaths(): IPathTile[];
        getVertPaths(): IPathTile[];
    }
}
declare module dorkapon.models {
    /**
     * The model attributes of a dorkapon entity
     */
    interface IDorkaponEntityAttributes {
        name: string;
        type: string;
        icon: string;
        moves: number;
        level: number;
        exp: number;
        hp: number;
        maxhp: number;
        attack: number;
        defense: number;
        magic: number;
        speed: number;
    }
    class DorkaponEntity extends Backbone.Model {
        attributes: IDorkaponEntityAttributes;
        static DEFAULTS: IDorkaponEntityAttributes;
        defaults(): any;
        /**
         * Apply a given amount of damage to this entity.  If the HP falls
         * below zero, it will be set to zero.
         *
         * @param value The amount of damage to apply.
         */
        damage(value: number): void;
        /**
         * Determine if a player is defeated.
         * @returns {boolean} True if the player's hp is 0.
         */
        isDefeated(): boolean;
        getAttack(): number;
        getDefense(): number;
        getMagic(): number;
        getSpeed(): number;
    }
}
declare module dorkapon.models {
    /**
     * The model attributes of a dorkapon entity
     */
    interface IDorkaponMonsterAttributes extends IDorkaponEntityAttributes {
    }
    class DorkaponMonster extends DorkaponEntity {
        attributes: IDorkaponMonsterAttributes;
        static DEFAULTS: IDorkaponMonsterAttributes;
        defaults(): any;
        static create(options: any): DorkaponMonster;
    }
}
declare module dorkapon.models {
    /**
     * The model attributes of a dorkapon player
     */
    interface IDorkaponPlayerAttributes extends IDorkaponEntityAttributes {
        basehp: number;
        baseattack: number;
        basedefense: number;
        basemagic: number;
        basespeed: number;
        levelhp: number;
        levelattack: number;
        leveldefense: number;
        levelmagic: number;
        levelspeed: number;
        armor: IDorkaponEquipment;
        weapon: IDorkaponEquipment;
        offenseMagic: IDorkaponEquipment;
        defenseMagic: IDorkaponEquipment;
    }
    class DorkaponPlayer extends DorkaponEntity {
        attributes: IDorkaponPlayerAttributes;
        static DEFAULTS: IDorkaponPlayerAttributes;
        defaults(): any;
        getAttack(): number;
        getDefense(): number;
        getMagic(): number;
        getSpeed(): number;
        static create(options: IDorkaponPlayerAttributes): DorkaponPlayer;
    }
}
declare module dorkapon.objects {
    class DorkaponEntity extends pow2.tile.TileObject {
        world: dorkapon.DorkaponGameWorld;
        model: models.DorkaponEntity;
    }
}
declare module dorkapon {
    class DorkaponAppStateMachine extends pow2.StateMachine {
        states: pow2.IState[];
    }
}
declare module dorkapon.states {
    class AppStateBase extends pow2.State {
        parent: DorkaponAppStateMachine;
        world: DorkaponGameWorld;
        constructor(parent: DorkaponAppStateMachine);
    }
    class AppMainMenuState extends AppStateBase {
        static NAME: string;
        name: string;
    }
    class AppCombatState extends AppStateBase {
        static NAME: string;
        name: string;
        attacker: models.DorkaponEntity;
        defender: models.DorkaponEntity;
        map: DorkaponTileMap;
        machine: DorkaponCombatStateMachine;
        scene: pow2.scene.Scene;
        exit(machine: DorkaponAppStateMachine): void;
        enter(machine: DorkaponAppStateMachine): void;
    }
    class AppMapState extends AppStateBase {
        static NAME: string;
        name: string;
        map: DorkaponTileMap;
        machine: DorkaponMapStateMachine;
        scene: pow2.scene.Scene;
        initialized: boolean;
        createPlayer(from: models.DorkaponPlayer, at?: pow2.Point): objects.DorkaponEntity;
        exit(machine: DorkaponAppStateMachine): void;
        enter(machine: DorkaponAppStateMachine): void;
        private _loadMap();
    }
}
